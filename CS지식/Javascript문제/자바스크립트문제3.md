#### 출처: https://github.com/lydiahallie/javascript-questions/blob/master/ko-KR/README-ko_KR.md#%EB%8B%B5-d

## JS 61번 문제

```
const person = { name: 'Lydia' };

Object.defineProperty(person, 'age', { value: 21 });

console.log(person);
console.log(Object.keys(person));
```

- A: { name: "Lydia", age: 21 }, ["name", "age"]
- B: { name: "Lydia", age: 21 }, ["name"]
- C: { name: "Lydia"}, ["name", "age"]
- D: { name: "Lydia"}, ["age"]

<details>
<summary>정답</summary>
<div>

답:B

JavaScript의 Object.defineProperty() 메소드 이해해야하는 문제
이 메소드를 사용하면 객체에 직접 새 속성을 추가하거나 이미 존재하는 속성을 수정하고, 그 속성의 특성을 정의할 수 있습니다.

```
 Object.defineProperty(person, 'age', { value: 21 });는 person 객체에 age라는 새 속성을 추가하고, 그 속성의 값을 21로 설정합니다.

Object.defineProperty()의 세 번째 매개변수로 전달된 객체 { value: 21 }에서는 value 외에도 writable, enumerable, configurable 등의 속성을 설정할 수 있습니다. 이들 속성은 각각 속성의 쓰기 가능 여부, 열거 가능 여부, 설정 가능 여부를 나타내는데, 기본값은 false입니다.

따라서 console.log(person);을 실행하면 { name: 'Lydia', age: 21 }이 출력됩니다.

하지만 console.log(Object.keys(person));을 실행하면 age 속성은 enumerable이 false로 기본 설정되어 있으므로 열거되지 않습니다. 따라서 ['name']만 출력됩니다.

Object.keys() 메소드는 객체의 열거 가능한 속성의 이름들을 배열로 반환합니다. enumerable이 false인 속성은 이 메소드로 열거할 수 없습니다. 따라서 age 속성은 Object.keys(person)의 결과에 포함되지 않습니다.
```

</div>
</details>

## JS 62번 문제

```
const settings = {
  username: 'lydiahallie',
  level: 19,
  health: 90,
};

const data = JSON.stringify(settings, ['level', 'health']);
console.log(data);
```

- A: "{"level":19, "health":90}"
- B: "{"username": "lydiahallie"}"
- C: "["level", "health"]"
- D: "{"username": "lydiahallie", "level":19, "health":90}"

<details>
<summary>정답</summary>
<div>

답:A

```
const obj = { name: "Kevin", age: 30, city: "Seoul" };

// replacer 함수를 사용하는 경우
const myJSON = JSON.stringify(obj, (key, value) => {
  if (key === 'age') return undefined;
  return value;
});
console.log(myJSON);  // "{"name":"Kevin","city":"Seoul"}"

// replacer 배열을 사용하는 경우
const myJSON2 = JSON.stringify(obj, ['name', 'city']);
console.log(myJSON2);  // "{"name":"Kevin","city":"Seoul"}"

// space 매개변수를 사용하는 경우
const myJSON3 = JSON.stringify(obj, null, 2);
console.log(myJSON3);
// "{
//   "name": "Kevin",
//   "age": 30,
//   "city": "Seoul"
// }"
```

</div>
</details>

## JS 63번 문제

```
let num = 10;

const increaseNumber = () => num++;
const increasePassedNumber = number => number++;

const num1 = increaseNumber();
const num2 = increasePassedNumber(num1);

console.log(num1);
console.log(num2);
```

- A: 10, 10
- B: 10, 11
- C: 11, 11
- D: 11, 12

<details>
<summary>정답</summary>
<div>

답: A

</div>
</details>

## JS 64번 문제

```
const value = { number: 10 };

const multiply = (x = { ...value }) => {
  console.log((x.number *= 2));
};

multiply();
multiply();
multiply(value);
multiply(value);
```

- A: 20, 40, 80, 160
- B: 20, 40, 20, 40
- C: 20, 20, 20, 40
- D: NaN, NaN, 20, 40

<details>
<summary>정답</summary>
<div>

답: C

```
객체는 참조에 의한 전달(Pass-by-Reference) 방식을 따릅니다. 따라서 함수 내부에서 객체의 속성 값을 변경하면 원래의 객체에도 그 변경이 반영됩니다. 이는 위에서 보여드린 multiply(value) 호출에서 value 객체의 number 속성 값이 변경된 것과 동일한 원리입니다.
```

```
원시 타입의 경우에는 함수 내부에서 값을 변경해도 원래 값에는 영향을 미치지 않습니다. 이는 원시 타입이 값에 의한 전달(Pass-by-Value) 방식을 따르기 때문입니다
```

</div>
</details>

## JS 65번 문제

```
[1, 2, 3, 4].reduce((x, y) => console.log(x, y));
```

- A: `1` `2` 그리고 `3` `3` 그리고 `6` `4`
- B: `1` `2` 그리고 `2` `3` 그리고 `3` `4`
- C: `1` `undefined` 그리고 `2` `undefined` 그리고 `3` `undefined` 그리고 `4` `undefined`
- D: `1` `2` 그리고 `undefined` `3` 그리고 `undefined` `4`

<details>
<summary>정답</summary>
<div>

답: D

</div>
</details>

## JS 66번 문제 Dog 클래스를 성공적으로 확장할 수 있는 생성자는 어느 것일까요?

```
class Dog {
  constructor(name) {
    this.name = name;
  }
};

class Labrador extends Dog {
  // 1
  constructor(name, size) {
    this.size = size;
  }
  // 2
  constructor(name, size) {
    super(name);
    this.size = size;
  }
  // 3
  constructor(size) {
    super(name);
    this.size = size;
  }
  // 4
  constructor(name, size) {
    this.name = name;
    this.size = size;
  }

};
```

- A: 1
- B: 2
- C: 3
- D: 4

<details>
<summary>정답</summary>
<div>

답: B
파생 클래스에서, super를 부르기 전에는 this 키워드에 접근할 수 없습니다.

</div>
</details>

## JS 67. 무엇이 출력 될까요?

```
// index.js
console.log('running index.js');
import { sum } from './sum.js';
console.log(sum(1, 2));

// sum.js
console.log('running sum.js');
export const sum = (a, b) => a + b;
```

- A: running index.js, running sum.js, 3
- B: running sum.js, running index.js, 3
- C: running sum.js, 3, running index.js
- D: running index.js, undefined, running sum.js

<details>
<summary>정답</summary>
<div>

답: B

이러한 코드가 실행되면, JavaScript는 import와 export가 있는 모듈을 로드할 때 특정한 순서를 따릅니다. 먼저, index.js가 실행될 때, sum.js를 import하라는 지시가 있으므로 sum.js가 먼저 로드됩니다. 그러므로 콘솔에는 먼저 'running sum.js'가 출력되고, 그 다음으로 'running index.js'가 출력됩니다.

그 후, index.js 파일 내에서 sum(1, 2)라는 함수 호출이 있으므로, 이 결과인 3이 콘솔에 출력됩니다.

</div>
</details>
