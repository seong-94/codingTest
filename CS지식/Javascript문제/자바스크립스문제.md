#### 출처: https://github.com/lydiahallie/javascript-questions/blob/master/ko-KR/README-ko_KR.md#%EB%8B%B5-d

## JS 1번 문제

```
function sayHi() {
  console.log(name);
  console.log(age);
  var name = 'Lydia';
  let age = 21;
}

sayHi();
```

- A: Lydia 그리고 undefined
- B: Lydia 그리고 ReferenceError
- C: ReferenceError 그리고 21
- D: undefined 그리고 ReferenceError

<details>
<summary>정답</summary>
<div>

답: D

호이스팅 과 스코프에 관한 문제,

var 과 let 의 차이점을 명확하게 알아야한다.

var 와 같은 경우 에는 전역함수로 name 변수를 선언 한다. 하지만 실제로 위에서는 name 의 변수는
정의되지 않았기 때문에, undefined 로 출력한다.

let (const) 도 같이 호이스팅이 발생하지만, var 와 다르게 변수를 선언(초기화) 하기 전에는 접근이 불가능
Temporal Dead Zone(TDZ) 이 발생합니다. 그래서 변수가 선언되기 전 변수에 접근하려고 하면, JavaScript는 ReferenceError를 반환합니다.

` TDZ:선언 전에 변수를 사용하는 것을 비 허용하는 개념상의 공간입니다.`

</div>
</details>

## JS 2번 문제

```
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}

for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}
```

- A: 0 1 2 그리고 0 1 2
- B: 0 1 2 그리고 3 3 3
- C: 3 3 3 그리고 0 1 2

<details>
<summary>정답</summary>
<div>

답: C

var 와 let 의 차이, 그리고 setTimeout 이라는 콜백함수 에 대한 정보

var 는 전역함수의 특성상 JavaScript 의 이벤트 큐 때문에 setTimeout의 콜백 함수는 루프가 실행된 후에 호출한다.
그러는중에 i 는 계속 ++ 되기 때문에 최종적으로 i 3 을 출력한다.

let 블록 스코프 이며 각각을 실행하는동안 i는 새로운 값을 가지며 각각의 값을 스코프 안에서 있기 떄문에
0 1 2 를 출력한다.

### 이러한 이유때문에 대부분 var 를 지양하고 프로젝트에서 사용하지 않는것이다.

</div>
</details>

## JS 3번 문제

```
const shape = {
  radius: 10,
  diameter() {
    return this.radius * 2;
  },
  perimeter: () => 2 * Math.PI * this.radius,
};

console.log(shape.diameter());
console.log(shape.perimeter());
```

- A: 20 그리고 62.83185307179586
- B: 20 그리고 NaN
- C: 20 그리고 63
- D: NaN 그리고 63

<details>
<summary>정답</summary>
<div>

답: B

함수의 종류 차이 function vs () =>

화살표 함수는 this 키워드를 일반함수와 다르게 스코프 안에서 찻기 때문에 radius 가 존재 하지 않는다.

</div>
</details>

## JS 4번 문제

```
+true;
!'Lydia';
```

- A: 1 그리고 false
- B: false 그리고 NaN
- C: false 그리고 false
<details>
<summary>정답</summary>
<div>

답: A

자바스크립트에서는 '' = false , true = 1 값이기 때문에
+true 는 +1 ,!'Lydia' 는 !true 이기때문에

답은 A

</div>
</details>

## JS 5번 문제

```
const bird = {
  size: 'small',
};

const mouse = {
  name: 'Mickey',
  small: true,
};
```

- A: mouse.bird.size 는 유효하지 않아요
- B: mouse[bird.size] 는 유효하지 않아요
- C: mouse[bird['size']] 는 유효하지 않아요
- D: 이 모든 것은 유효해요.

<details>
<summary>정답</summary>
<div>

답: A

JavaScript에서 모든 객체의 키는 문자열입니다.

JavaScript는 문장을 해석 또는 분해합니다. 대괄호 표기를 사용하면 첫 번째 열린 대괄호 [를 보고 닫힌 대괄호]를 찾을 때까지 진행해요. 다 찾은 후에만 문장을 평가할 거예요.

mouse[] 안에 존재하는 bird.size 값을 먼저 찻은 뒤에 bird.size 값을 mouse 객체의 키값에서 찻습니다.

하지만 mouse.bird 는 mouse 의 객체 안에서 bird 라는 키값이 없기 때문에 유효하진 않습니다.

</div>
</details>

## JS 6번 문제

```
let c = { greeting: 'Hey!' };
let d;

d = c;
c.greeting = 'Hello';
console.log(d.greeting);
```

- A: Hello
- B: Hey!
- C: undefined
- D: ReferenceError
- E: TypeError

<details>
<summary>정답</summary>
<div>

답: A

객체의 얇은 복사 깊은 복사의 차이를 이해 해야하는 문제

JavaScript에서 = 로 데이터를 넘겨주게 되면 얇은 복사를 하기 떄문에 같은 주소값을 참조하기 떄문에

같은 데이터를 참조한다.

</div>
</details>

## JS 7번 문제

```
let a = 3;
let b = new Number(3);
let c = 3;

console.log(a == b);
console.log(a === b);
console.log(b === c);
```

- A: true false true
- B: false false true
- C: true false false
- D: false true true

<details>
<summary>정답</summary>
<div>

답: C

== 와 === 차이 점 을 이해해야 한다.

== 데이터 의 값만 같으면 true === 는 데이터의 값과 타입 모두 일치해야한다.

</div>
</details>

## JS 8번 문제

```
class Chameleon {
  static colorChange(newColor) {
    this.newColor = newColor;
    return this.newColor;
  }

  constructor({ newColor = 'green' } = {}) {
    this.newColor = newColor;
  }
}

const freddie = new Chameleon({ newColor: 'purple' });
console.log(freddie.colorChange('orange'));
```

- A: orange
- B: purple
- C: green
- D: TypeError

<details>
<summary>정답</summary>
<div>

답: D

colorChange함수는 static 입니다. 정적 메소드는 그것이 만들어지는 생성자에서만 살아있도록 설계되어,
어떤 자식들도 상속받을 수 없습니다.
freddie는 자식이기 때문에, 이 함수는 상속되지 않아 freddie인스턴스에서는 이용할 수 없어요: TypeError가 가 출력됩니다.

</div>
</details>

## JS 9번 문제

```
let greeting;
greeting = {}; // Typo!
console.log(greeting);
```

- A: {}
- B: ReferenceError: greeting is not defined
- C: undefined
<details>
<summary>정답</summary>
<div>

답: A

빈객체를 선언하였기 때문에 당연하게 A 이다.

이것을 피하려면, "use strict"를 사용할수있습니다.
이렇게 하면 변수를 어떤 것과 동일하게 설정하기 전에 변수를 선언했는지 확인할 수 있습니다.

</div>
</details>

## JS 10번 문제

```
let greeting;
greeting = {}; // Typo!
console.log(greeting);
```

- A: {}
- B: ReferenceError: greeting is not defined
- C: undefined
<details>
<summary>정답</summary>
<div>

답: A

빈객체를 선언하였기 때문에 당연하게 A 이다.

이것을 피하려면, "use strict"를 사용할수있습니다.
이렇게 하면 변수를 어떤 것과 동일하게 설정하기 전에 변수를 선언했는지 확인할 수 있습니다.

</div>
</details>

## JS 11번 문제

```
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

const member = new Person('Lydia', 'Hallie');
Person.getFullName = function () {
  return `${this.firstName} ${this.lastName}`;
};

console.log(member.getFullName());
```

- A: {}
- B: ReferenceError: greeting is not defined
- C: undefined
<details>
<summary>정답</summary>
<div>

답: A

JavaScript 에서는 함수는 객체 이며 그렇기 때문에 메소드 getFullName 은 생성자 함수 객체 자체에 추가 됩니다.

member.getFullName()은 Person 객체의 인스턴스인 member에 대해 getFullName 메소드를 호출하는 것입니다. 그러나 이 경우, getFullName은 Person의 프로토타입에 정의되지 않았기 때문에 member.getFullName()은 TypeError를 발생시킵니다. 이는 getFullName이 member의 메소드로 인식되지 않기 때문입니다.

반면에, Person.getFullName()은 Person 함수 객체에 직접 추가된 메소드를 호출하는 것입니다. 이 경우 'this' 키워드는 Person 함수 객체를 가리키게 됩니다. 그러나 firstName과 lastName 프로퍼티는 Person의 인스턴스에 있으므로, Person.getFullName()을 호출하면 undefined undefined를 반환하게 됩니다. 왜냐하면 Person 함수 객체에는 firstName과 lastName이라는 프로퍼티가 없기 때문입니다.

따라서, 일반적으로 객체의 인스턴스에 대해 메소드를 사용하려면 해당 메소드는 생성자 함수의 프로토타입에 정의되어야 합니다. 이렇게 하면 모든 인스턴스가 메소드에 접근할 수 있습니다. 예를 들어 다음과 같이 작성할 수 있습니다.

```
Person.prototype.getFullName = function () {
  return `${this.firstName} ${this.lastName}`;
};
```

</div>
</details>
