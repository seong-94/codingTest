
# React State

## 정의 및 사용법
### 클래스 컴포넌트
클래스 컴포넌트에서는 `this.state`를 통해 state를 사용합니다. 초기 state는 클래스의 생성자에서 `this.state`를 설정함으로써 정의할 수 있습니다. state를 변경하려면 반드시 `this.setState()` 메서드를 사용해야 합니다.

### 함수 컴포넌트
함수 컴포넌트에서는 `useState` Hook을 사용하여 state를 관리할 수 있습니다. `useState`는 초기 state 값을 인자로 받아, 현재 state 값과 이를 업데이트하는 함수를 배열로 반환합니다.

## 응용
State는 사용자 인터랙션, 네트워크 응답 등에 반응하여 동적으로 UI를 업데이트하는 데 사용됩니다. 사용자가 버튼을 클릭하면 해당 이벤트 핸들러가 state를 업데이트하고, 이로 인해 버튼의 텍스트, 색상 등이 변경될 수 있습니다.

## 주의점
- State는 직접 변경하면 안 됩니다. State를 변경하려면 반드시 `this.setState()` (클래스 컴포넌트) 또는 `setState` 함수 (함수 컴포넌트)를 사용해야 합니다.
- State 업데이트는 비동기적으로 이루어질 수 있으므로, 현재 state를 기반으로 새 state를 계산할 때는 함수형 업데이트를 사용해야 합니다.
- State는 최소한으로 유지되어야 하며, 계산 가능한 값을 state로 만들지 않아야 합니다. 예를 들어, 항목 목록의 길이를 state로 저장하는 대신 항목 목록 자체를 state로 저장하고 필요할 때 길이를 계산하는 것이 좋습니다.



### Quiz
1.리액트 앱에서 State(상태)의 존재 목적은? 
변화가 생경르 때 리액트가 컴포넌트를 재평가 하는 데이터


리액트 훅의 중요한 규칙은 두 가지입니다
2.최상위에서만 Hook을 호출해야 합니다: Hook을 반복문, 조건문, 중첩된 함수 내에서 호출하지 않아야 합니다. 이는 훅의 호출 순서가 항상 같아야 한다는 리액트의 기본 규칙 때문입니다. 
```
function App() {
  const [count, setCount] = useState(0);
  if (count > 2) {
    useEffect(() => {
      document.title = `Count: ${count}`;
    });
  }
  return <div>{count}</div>;
}
```
위의 코드에서 useState와 useEffect는 최상위에서 호출되어야 하며, 조건문 내부에서 호출되어서는 안 됩니다.

3
React 함수 내에서만 Hook을 호출해야 합니다: 이는 리액트의 함수 컴포넌트 또는 커스텀 훅 내에서만 Hook을 호출해야 한다는 규칙입니다. 일반 자바스크립트 함수에서는 Hook을 호출하지 않아야 합니다.
예를 들어, 아래와 같이 일반 함수에서 Hook을 호출하는 것은 허용되지 않습니다.

```
function regularFunction() {
  const [count, setCount] = useState(0); // ❌ Hook cannot be called inside a regular function
}

```
위의 코드에서 useState는 리액트 함수 컴포넌트 또는 커스텀 훅 내에서만 호출되어야 합니다.

이러한 규칙들은 훅의 동작 방식을 이해하고, 예기치 않은 버그를 방지하는 데 도움이 됩니다. 이 규칙들을 자동으로 검사해주는 ESLint 플러그인인 eslint-plugin-react-hooks를 사용하면 코드를 더욱 안전하게 관리할 수 있습니다.


4. "파생된 State(상태)"와 "계산된 값"이라는 개념은 주로 컴포넌트의 상태나 속성(props)에 의존하는 값들을 의미합니다. 이 값들은 상태나 속성이 변경될 때마다 자동으로 업데이트됩니다.

1. **파생된 State(상태):** 이는 상태의 변화에 따라 계산되어 업데이트되는 상태를 의미합니다. 예를 들어, 사용자의 입력에 따라 변하는 검색 필터 상태와, 이에 따라 필터링된 결과를 저장하는 상태가 있을 수 있습니다. 여기서 필터링된 결과는 검색 필터 상태에 의존하여 계산되므로 파생된 상태라고 할 수 있습니다. 

2. **계산된 값:** 이는 주로 렌더링 과정에서 계산되는 값들을 의미합니다. 이 값들은 상태나 속성에 의존하여 계산되며, 렌더링 과정에서 사용됩니다. 예를 들어, 리스트의 아이템 수를 표시하는 경우, 아이템 수는 리스트 상태에 의존하여 계산되므로 계산된 값이라고 할 수 있습니다.

이러한 개념은 컴포넌트의 상태 관리를 더 효율적으로 하고, 렌더링 성능을 최적화하는 데 중요한 역할을 합니다. 특히, 상태 변화에 따른 불필요한 연산을 최소화하고, 변화가 없을 때는 이전에 계산한 결과를 재사용함으로써 성능을 향상시킬 수 있습니다.


React에서는 컴포넌트 밖에 함수를 선언하고 이를 컴포넌트 내에서 사용하는 방식이 종종 사용됩니다. 이렇게 하는 이유는 주로 다음과 같습니다:

재사용성 (Reusability): 함수를 컴포넌트 밖에서 정의하면, 해당 함수를 여러 컴포넌트에서 재사용할 수 있습니다. 이렇게 하면 코드 중복을 줄일 수 있으며, 유지 보수도 용이해집니다.

최적화 (Optimization): 컴포넌트 내에서 함수를 선언하면, 컴포넌트가 재렌더링될 때마다 함수도 새로 생성됩니다. 이는 메모리 사용량을 증가시키며 성능에 영향을 줄 수 있습니다. 반면, 함수를 컴포넌트 밖에서 선언하면 한 번만 생성되므로 이런 부담을 줄일 수 있습니다.

테스트 용이성 (Testability): 컴포넌트 밖에서 함수를 선언하면, 해당 함수를 컴포넌트와 독립적으로 테스트할 수 있습니다. 이는 단위 테스트를 작성하기 쉽게 만들어주며, 디버깅도 용이해집니다.

그러나 함수가 컴포넌트의 상태나 props에 의존하는 경우에는 컴포넌트 내부에서 선언해야 합니다. 왜냐하면 컴포넌트 밖에서 선언된 함수는 컴포넌트의 상태나 props에 접근할 수 없기 때문입니다. 이런 경우에는 useCallback 등의 Hook을 사용하여 함수를 메모이제이션하는 방식으로 최적화를 할 수 있습니다.****



